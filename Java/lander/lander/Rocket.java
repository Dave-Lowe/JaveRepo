/* 
	Newton.java

	Author:			Dave Lowe
	Description:	Rocket Object. Models a simple Rocket with Left and Right
					Thrusters and a main engine.  This Object Could be modified to 
					Model anything from a lunar lander to a chunk of debri.
*/

package lander;

import java.awt.*;
import java.awt.event.*;
import java.applet.*;

public class Rocket extends Applet
{

	/*  x & y are the coordinates of the rocket at any time

	deltax and deltay are the horezontal and vertical components of the Rocket's velocity */

	private double x,y;
	private double deltax,deltay;
	
	/* Angle is the rocket's angle, and deltaand is it's angular velocity  */
	
	private double angle, deltaang;
	
	/*  Rocketshape x & y hold the relative coordinates of it's four corners to it's own axis  
	    flame shape x and y hold the relative positions of the flames, the first three are the corners of the 
	    main engine flare, the last four define the positions of the four manouvering thrusters  */
	
	private int rocketshapex[] 	= new int[31];
	private int rocketshapey[] 	= new int[31];
	
	private int flameshapex[]	= new int[7];
	private int flameshapey[] 	= new int[7];
	
	
	/*  rocketact x and y hold actual coordinates of the rockets corners after they have been rotated and shifted
	 	to the correct possition on the screen. These are the coordinates that are used to actually draw the Rocket.
	 	Similarly flameact x and y hold the actual positions of the flames */
	
	private int rocketactx[]    = new int[31];
	private int rocketacty[]	= new int[31];
	
	private int flameactx[]		= new int[7];
	private int flameacty[]		= new int[7];
	
	
	/* enginePower and thrusterPower hold the power of the main engines and the lateral thrusters  */
	
	private double enginePower, thrusterPower;
	
	
	/* Mass hold the mass of the Rocket  */
	
	
	private double mass;
	
	
	/* thrust and anglethrust are constants which the accelaration generated by the engines */
	
	private double thrust, anglethrust;
	
	
		
	/* horizontal and vertical component of planets gravity */
		
	private double gravx, gravy;
		
		
	/* Colour of Rocket */
		
	private Color RocketColor = new Color(255,0,0);
	
	/* Colour of flames */
	
	private Color yellow = new Color(255,255,0);
	
	
		
	
	boolean isStandalone = false;

	public Rocket(double initx, double inity,double initdeltax, double initdeltay, double initangle, double initmass, double initepower, double inittpower, Color c) 
	{
	
		/* Set up relative coordinates for Rocket   */
		
		rocketshapex[0] = -2;
		rocketshapex[1] = -5;
		rocketshapex[2] = -5;
		rocketshapex[3] = -4;
		rocketshapex[4] = -4;
		rocketshapex[5] = -3;
		rocketshapex[6] = -3;
		rocketshapex[7] = -2;
		rocketshapex[8] = 2;
		rocketshapex[9] = 5;
		rocketshapex[10] = 5;
		rocketshapex[11] = 2;
		rocketshapex[12] = 5;
		rocketshapex[13] = 5;
		rocketshapex[14] = 10;
		rocketshapex[15] = 11;
		rocketshapex[16] = 11;
		rocketshapex[17] = 8;
		rocketshapex[18] = 8;
		rocketshapex[19] = 9;
		rocketshapex[20] = 5;
		rocketshapex[21] = -5;
		rocketshapex[22] = -9;
		rocketshapex[23] = -8;
		rocketshapex[24] = -8;
		rocketshapex[25] = -11;
		rocketshapex[26] = -11;
		rocketshapex[27] = -10;
		rocketshapex[28] = -5;
		rocketshapex[29] = -5;
		rocketshapex[30] = -2;
	
		
		rocketshapey[0] = 0;
		rocketshapey[1] = 3;
		rocketshapey[2] = 7;
		rocketshapey[3] = 8;
		rocketshapey[4] = 12;
		rocketshapey[5] = 12;
		rocketshapey[6] = 9;
		rocketshapey[7] = 10;
		rocketshapey[8] = 10;
		rocketshapey[9] = 7;
		rocketshapey[10] = 3;
		rocketshapey[11] = 0;
		rocketshapey[12] = 0;
		rocketshapey[13] = 0;
		rocketshapey[14] = -9;
		rocketshapey[15] = -9;
		rocketshapey[16] = -10;
		rocketshapey[17] = -10;
		rocketshapey[18] = -9;
		rocketshapey[19] = -9;
		rocketshapey[20] = -5;
		rocketshapey[21] = -5;
		rocketshapey[22] = -9;
		rocketshapey[23] = -9;
		rocketshapey[24] = -10;
		rocketshapey[25] = -10;
		rocketshapey[26] = -9;
		rocketshapey[27] = -9;
		rocketshapey[28] = 0;
		rocketshapey[29] = 0;
		rocketshapey[30] = 0;
			
		
		/* Set up relative coordinates for main engine flare  */
		
		flameshapex[0] 	= -2;
		flameshapex[1] 	= 0;
		flameshapex[2]	= 2;
		
		flameshapey[0]	= -5;
		flameshapey[1]	= -16;
		flameshapey[2]	= -5;
		
		
		/* Set up relative coordinates for the manouvering thrusters  */
		
		flameshapex[3]	= 6;
		flameshapex[4]	= -6;
		flameshapex[5] 	= 6;
		flameshapex[6]	= -6;
		
		flameshapey[3]	= 7;
		flameshapey[4]	= 7;
		flameshapey[5]	= 3;
		flameshapey[6]	= 3;
		
		
			
	
		/* Set up constants  */
		
		enginePower = initepower;
		
		thrusterPower = inittpower;
		
		mass = initmass;
		
		
				
		/*  Set up initial Values */
		
		
		x = initx;
		y = inity;
		
		angle = initangle;
		
		
		deltax = initdeltax;
		deltay = initdeltay;
		
		deltaang = 0;
		
		gravx	 = 0;
		gravy	 = 0;
		
		RocketColor = c;
						
	}
	
	
				
	
	public void UpdatePosition(boolean throttle, boolean left, boolean right)
	{	
		/* determine thrut and angle thrust (could vary if mass changes)  */
		
		thrust = enginePower/mass;
		
		anglethrust = thrusterPower/mass;
		
				
		/* If any buttons pressed adjust angular velocity accordingly */	
			
		if (left)
		{
			deltaang = deltaang - anglethrust;
		}
		if (right)
		{
			deltaang = deltaang + anglethrust;
		}
			
			
		/* Calculate new angle and adjust to bring into a sensible range if necessary */
		
		angle = angle + deltaang;
		
		if (angle > (2*java.lang.Math.PI))
		{
			angle = angle - (2*java.lang.Math.PI);
		}
		
		if (angle < 0)
		{
			angle = angle + (2*java.lang.Math.PI);
		}	
		
		
		
		if (throttle)
		{
			deltax = deltax - (thrust * java.lang.Math.sin(angle));
			deltay = deltay + (thrust * java.lang.Math.cos(angle));
		}	
		
			
		/*Calculate new y position  */
		
		y = y + deltay;
		
		
		/* Calculate new x position  */
		
		x = x + deltax;
		
		
		
		/* calculate actual coordintates for the Rocket  */
		
		CalcRocketCoords();
		
		
		/* calculate the actual coordinates for the flames */
		
		CalcFlameCoords();
		
		
		
	}
	
	
	public void ApplyGravity()
	{
		/* calculate the horizontal and vertical components of gravity  */
		
			
		gravx = 0;
		gravy = -0.01;
			
		deltax	= deltax - gravx;
		deltay	= deltay - gravy;

	}	
	
	public void Bounce_y()
	{
		/* Vertical component of velocity is reversed but with a slight loss of energy */
		deltay = deltay * -0.75;
	}	 
	
	public void Friction_x()
	{
		/* Apply some Friction to the horizontal component of velocity */
		deltax = deltax * 0.85;
		
		/* Apply friction to the Angular Velocity */
		
		deltaang = deltaang * 0.85;
	}
	
	public void Spin_x()
	{

		/* First, if the angle of the Lander is between 3.59159 and 3.79159, then the legs will land first and cause
			the lander to spin Towards the vertical - This works to Stabalise the Lander*/
			
		if (angle > 2.54159 && angle < 3.74159)
		{
			deltaang = deltaang + 0.01*(3.14159 - angle);
		}
		
		/* Second, impart some spin propartional to the horizontal velocity Ragrdless of which way up the lander is 
		
		- these two Forces could Work against each other */
		
		deltaang = deltaang + (0.01 * deltax);
	}
		
			
		
	public double FindRange (double x1, double y1)
	{
		double rsquared, distx, disty;
		
		distx = x - x1;
		disty = y - y1;
		
		rsquared = java.lang.Math.pow(distx,2) + java.lang.Math.pow(disty,2);
		
		return(java.lang.Math.sqrt(rsquared));
	}	


	public double GetXCoord ()
	{
		return(x);
	}
	
	
	public double GetYCoord ()
	{
		return(y);
	}
	
	public double GetDeltaX()
	{
		return(deltax);
	}
	
	
	public double GetDeltaY()
	{
		return(deltay);
	}
	
	public double GetSpeed()
	{
		return(java.lang.Math.sqrt(java.lang.Math.pow(deltax,2) + java.lang.Math.pow(deltay,2)));
	}
			
	public double GetAngle ()
	{
		return(angle);
	}


	public double GetMass ()
	{
		return(mass);
	}
		
		
	public Color GetColor()
	{
		return(RocketColor);
	}			
	
	public void SetXCoord(double x1)
	{
		x=x1;
	}
	
	public void SetYCoord(double y1)
	{
		y=y1;
	}
	
	
	public void SetAngle(double a1)
	{
		angle=a1;
	}						
			
	
			
			
	
	public void DrawRocket(Graphics g, boolean throttle, boolean left, boolean right)
	{
		
		
		/* Draw the Rocket  */
		
		g.setColor(RocketColor);
		g.fillPolygon(rocketactx,rocketacty,31);			
		
		
		/* draw the main engine flame if throttle on */
		
		if (throttle)
		{
			g.setColor(yellow);
			g.fillPolygon(flameactx,flameacty,3);	
		}	
		
		
		/* draw thusters 3 and 6 if left button on and reset the flag */
		
		if (left)
		{
			g.setColor(yellow);
			g.fillOval(flameactx[3]-2,flameacty[3]-2,4,4);
			g.fillOval(flameactx[6]-2,flameacty[6]-2,4,4);
			
						
		}
				
		
		/* draw thrusters 4 and 5 if right button on and reset the flag*/
		
		if(right)
		{
			g.setColor(yellow);
			g.fillOval(flameactx[4]-2,flameacty[4]-2,4,4);
			g.fillOval(flameactx[5]-2,flameacty[5]-2,4,4);
			
				
		}
		
		
	}	


private void CalcRocketCoords()
	{
		int n;
		double r, theta;
		
		double localx,localy;
		
		/*  for each value of Rocketshapex and y  */
		
		for (n=0;n<31;n++)
		{
			/* convert Rocktshape x and y to polar coordinates  */
			
			r = java.lang.Math.sqrt(java.lang.Math.pow(rocketshapex[n],2) + 
									java.lang.Math.pow(rocketshapey[n],2));
			theta = java.lang.Math.atan2(rocketshapey[n],rocketshapex[n]);
			
			
			/* Scale up image by x% */
			
			r = r * 1.0;
			
			/* rotate each point around by angle  */
			
			theta = theta + angle;
			
			/* convert back to reactangular coords  */
			
			localx = r * java.lang.Math.cos(theta);
			localy = r * java.lang.Math.sin(theta);
			
			/* add actual x and y coords and store results in Rocketactx and rocketacty  */
			
			localx = localx + x;
			localy = localy + y;
			
			rocketactx[n] = (int)(java.lang.Math.round(localx));
			rocketacty[n] = (int)(java.lang.Math.round(localy));
		}
	}		
			
			
	private void CalcFlameCoords()
	{
		int n;
		double r, theta;
		
		double localx,localy;
		
		/*  for each value of Rocketshapex and y  */
		
		for (n=0;n<7;n++)
		{
			/* convert flameshape x and y to polar coordinates  */
			
			r = java.lang.Math.sqrt(java.lang.Math.pow(flameshapex[n],2) + 
									java.lang.Math.pow(flameshapey[n],2));
			theta = java.lang.Math.atan2(flameshapey[n],flameshapex[n]);
			
			/* add a random 'flicker' to the main engine flare  */
			
			if(n==1)
			{
				r = r + ((8*java.lang.Math.random())-4);
			}	
			
			/*  Scale up r by x% */
			
			r = r * 1.0;
			
			/* rotate each point around by angle  */
			
			theta = theta + angle;
			
			/* convert back to reactangular coords  */
			
			localx = r * java.lang.Math.cos(theta);
			localy = r * java.lang.Math.sin(theta);
			
			/* add actual x and y coords and store results in flametactx and flametacty  */
			
			localx = localx + x;
			localy = localy + y;
			
			flameactx[n] = (int)(java.lang.Math.round(localx));
			flameacty[n] = (int)(java.lang.Math.round(localy));
		}
	}		
			


	// Retrieve the value of an applet parameter
	public String getParameter(String key, String def) 
	{
		return isStandalone ? System.getProperty(key, def) :
			(getParameter(key) != null ? getParameter(key) : def);
	}

	// Get info on the applet parameters
	public String[][] getParameterInfo() 
	{
		return null;
	}

	// Get applet information
	public String getAppletInfo() 
	{
		return "Applet Information";
	}

	// Initialize the applet
	
	public void initComponents() throws Exception
	{
// BEGIN GENERATED CODE
		// the following code sets the frame's initial state
		setLocation(new java.awt.Point(0, 0));
		setLayout(null);
		setSize(new java.awt.Dimension(800, 600));


// END GENERATED CODE
	}
	


}
